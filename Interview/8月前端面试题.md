title: 8 月前端面试题
date: 2018-08-21 21:02:58
tags: 面试

---

<!--more-->

## 怎么去设计一个封装组件

- 组件封装的目的是为了重用，提高开发效率和代码质量
- 低耦合，单一职责，可复用性，可维护性
- 前端组件化设计思路：http://ijser.cn/2017-06-25-web-component-design-in-front-end/

## js 异步加载的方式

- 渲染引擎遇到 script 标签会停下来，等到执行完脚本，继续向下渲染
- defer 是“渲染完在执行”，async 是下载完就执行，defer 如果有多个脚本，会按照在页面中出现的顺序加载，多个 async 脚本不能保证加载顺序
- 加载 es6 模块的时候设置 type=module，异步加载不会造成阻塞浏览器，页面渲染完在执行，可以同时加上 async 属性，异步执行脚本（利用顶层的 this 等于 undefined 这个语法点，可以侦测当前代码是否在 es6 模块之中）

## css 动画和 js 动画的差异

- 代码复杂度，js 动画代码相对复杂一些
- 动画运行时，对动画的控制程度，js 能够让动画暂停，取消，终止，css 动画不能添加事件
- 动画性能，js 动画多了一个 js 解析的过程，性能不如 css 动画好

## xss 和 CSRF 两种跨站攻击

- xss 跨站攻击脚本，主要是前端层面的，用户在输入层面插入攻击脚本，改变页面的显示，或则窃取网站 cookie，预防方法：不相信用户的所有操作，对用户输入进行一个转义，不允许 js 对 cookie 的读写
- CSRF 跨站请求伪造，以你的名义，发送恶意请求，通过 cookie 加参数等形式过滤
- 我们没法彻底杜绝攻击，只能提高攻击门槛

## 事件委托，目的，功能，写法

- 把一个或者一组元素的事件委托到他的父层或者更外层元素上
- 优点，减少内存消耗，动态绑定事件
- target 是出发时间的最具体的元素，currenttarget 是绑定事件的元素（在函数中一般等于 this）
- JavaScript 事件委托详解：https://zhuanlan.zhihu.com/p/26536815

## 线程，进程

- 线程是最小的执行单元，进程是最小的资源管理单元
- 一个线程只能属于一个进程，而一个进程可以有多个线程，但至少有一个线程

## 负载均衡

- 当系统面临大量用户访问，负载过高的时候，通常会使用增加服务器数量来进行横向扩展，使用集群和负载均衡提高整个系统的处理能力
- 服务器集群负载均衡原理：https://www.zhihu.com/question/22610352

## 什么是 cdn 缓存

- cdn 是一种部署策略，根据不同的地区部署类似 nginx 这种服务，会缓存静态资源。前端在项目优化的时候，习惯在讲台资源上加一个 hash 值，每次更新的时候去改变这个 hash，hash 值变化的时候，服务会去重新取资源
- cdn 是一个经策略性部署的整体系统，包括分布式 储存，负载均衡，网络请求的重定向和内容管理四个条件
- cdn 百度百科：https://baike.baidu.com/item/CDN

## 闭包的写法，闭包的作用，闭包的缺点

- 使用闭包的目的——隐藏变量，间接访问一个变量，在定义函数的词法作用域外，调用函数
- 闭包的内存泄漏，是 IE 的一个 bug，闭包使用完成之后，收回不了闭包的引用，导致内存泄露
- js 中的闭包是什么：https://zhuanlan.zhihu.com/p/22486908?refer=study-fe

- 造成闭包泄露的实验：http://www.cnblogs.com/rubylouvre/p/3345294.html

## 跨域，谁限制的跨域，怎么解决

- 浏览器的同源策略导致了跨域
- 用于隔离潜在恶意文件的重要安全机制
- jsonp，允许 script 加载第三方资源：https://segmentfault.com/a/1190000008445998
- nginx 反向代理（nginx 服务内部配置 Access-Control-Allow-Origin\*）
- cors 前后端协作设置请求头部，Access-Control-Allow-Origin 等头部信息
- iframe 嵌套通讯，PostMessage

## js 种常见的内存泄漏陷阱

- 内存泄漏会导致一系列问题，比如：运行缓慢，奔溃，高延迟
- 内存泄漏是指你用不到的变量，依旧占据着内存空间，不能被再次利用起来
- 意外的全局变量，这些都是不会被回收的变量（除非设置 null 或者被重新赋值），特别是那些涌来临时存储大量信息的变量
- 周期函数一直在运行，处理函数并不会被回收，jq 在移除节点前都会将事件监听移除
- js 代码中有对 DOM 节点的引用，dom 节点被移除的时候，引用还维持
- js 中常见的四种内存泄漏陷阱：http://web.jobbole.com/88463/

## babel 把 es6 转换成 es5 的原理是什么

- 他就是个编译器，输入语言是 es6+，编译目标语言是 es5
- babel 官方工作原理
- 解析： 将代码字符串解析成抽象语法树
- 变换：对抽象语法树进行变换 caozuo
- 在建：根据变换后的抽象语法树再生成代码字符串

## Promise 模拟终止

- 当新对象保持 pending 状态时，元 Promise 链将会中止执行
- return new Promise(() => {}); // 返回 pending 状态的 Promise 对象
- 从如何停掉 Promise 链说起（promise 内存泄漏问题）：https://github.com/xieranmaya/blog/issues/5

## promise 放在 try catch 里面有什么结果

- Promise 对象的错误具有冒泡性质，会一直向后传递，知道被捕获为止，也就是说，错误会被下一个 catch 语句捕获
- 当 Promise 连中抛出一个错误时，错误信息沿着链路向后传递，直至被捕获

## 网站性能优化

- http 请求方面，减少请求数量，请求体积，对应的做法是，对项目资源进行压缩，控制项目资源的 dns 解析在 2 到 4 个域名,提取公共的样式，公共的组件，雪碧图，缓存资源
- 压缩资源，提取公共资源压缩，提取 css，js 公共方法
- 不要压缩图片，使用雪碧图，使用字体图表（阿里矢量图标库）
- 使用 cdn，抛开无用的 cookie
- 减少重绘重排，css 属性读写分离，最好不要用 js 修改样式，dom 离线更新，渲染前指定图片的大小
- js 代码层面的优化，减少对字符串的计算，合理使用闭包，首屏的 js 资源加载放在最底部

## js 自定义事件实现

- 原生提供了三个方法实现自定义事件
- createEvent，设置事件类型，是 html 事件还是鼠标事件
- initEvent 初始化事件，事件名称，是否允许冒泡，是否组织自定义事件
- dispatchEvent 触发事件

## angular 双向数据绑定与 vue 数据的双向数据绑定

- 二者都是 mvvm 模式开发的典型代表
- angular 是通过脏检测实现，angular 会将 ui 事件，请求事件，settimeout 这类延迟的对象放入到事件监测的藏队列，当数据变化的时候，触发$diget 方法进行数据的更新，视图的渲染
- vue 通过数据属性的数据劫持和发布订阅的模式实现，大致可以理解成由三个模块组成，Observer 完成对数据的劫持，compile 完成对模板片段的渲染，watcher 作为桥梁连接二者，订阅数据变化及更新视图

## get 与 post 通讯的区别

- Get 请求能缓存，post 不能
- post 相对 get 安全一点点，因为 get 请求都包含在 url 里，且会被浏览器保存历史记录，post 不会，但是在抓包的情况下都是一样的
- post 可以通过 request body 来传输比 get 更多的数据，get 没有这个技术
- url 有长度限制，会影响 get 请求，但是这个长度限制是浏览器规定的，不是 RFC 规定的
- post 支持更多的编码类型且不对数据类型限制

## 有没有去研究 webpack 的一些原理和机制，怎么实现的

- 解析 webpack 配置参数，何冰从 shell 传入和 webpack.config.js 文件里配置的参数，生产最后的配置结果
- 注册所有配置的插件，好让插件监听 webpack 构建生命周期的事件节点，以做出对应的反应。
- 从配置的 entry 入口文件开始解析文件构建 AST 语法树，找出每个文件所依赖的文件，递归下去
- 在解析文件递归的过程中根据文件类型和 loader 配置找出合适的 loader 用来对文件进行转换
- 递归完后得到每个文件的最终结果，根据 entry 配置生成代码块 chunk
- 输出所有 chunk 到文件系统

## es6 模块与 commonjs 模块的差异

- commonjs 模块输出的是一个值的拷贝，es6 模块输出的是一个值得引用
- commonjs 模块是运营时加载，es6 模块是编译时输出接口
- es6 输入的模块变量，只是一个符号链接，所以这个变量是只读的，对他进行重新赋值就会报错

## 模块加载 AMD,CMD,Commonjs Modules/2.0 规范

- 这些规范的目的都是为了 JavaScript 的模块化开发，特别是在浏览器端的
- 对于依赖的模块，AMD 是提前执行，CMD 是延迟执行
- CMD 推崇依赖就近，AMD 推崇依赖前置

## Node 事件循环，js 事件循环差异

- nodejs 的事件循环分为六个阶段
- 浏览器和 node 环境下，microtask 任务队列的执行时机不同
  - nodejs 中，microtask 在事件循环的各个阶段之间执行
  - 浏览器端，microtask 在事件循环的 macrotask 执行完之后执行
- 递归的调用 process.nextTick()会导致 I/O starving, 官方推荐使用 setImmediate()

## 深拷贝和浅拷贝问题

- 深拷贝和浅拷贝是只针对 Object 和 Array 这样的复杂类型的
- 也就是说 a 和 b 指向了同一块内存，所以修改器中的任意的值，另一个只都会随之变化，这就是浅拷贝
- 浅拷贝，Object.assign()方法用于将所有可枚举的属性的值从一个或多个源对象复制到目标对象。他将返回目标对象
- 深拷贝，JSON.parse()和 JSON.stringify()给了我们一个基本的解决方法。但是函数不能被正确处理。

https://segmentfault.com/a/1190000015916686
